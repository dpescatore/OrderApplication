package com.example.order.service.impl;

import java.util.Date;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Random;

import javax.validation.Valid;

import com.example.order.model.Order;
import com.example.order.model.Photographer;
import com.example.order.model.Order.State;
import com.example.order.repository.OrderRepository;
import com.example.order.service.OrderService;
import com.example.order.exception.OrderException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

/**
 * @author dpescatore
 */
@Service
public class OrderServiceImpl implements OrderService {
    private static final String MOCKED_PHOTOGRAPHERS_URL = "https://run.mocky.io/v3/c099cc58-4410-4bfc-a60c-d54f88d076cc";
    @Autowired
    private OrderRepository orderRepository;

    /**
     * Find order specified by input parameter
     * 
     * @param orderId the id of the order
     * @return found order
     * @throws OrderException when not find specified order
     */
    public Order findById(Long orderId) throws OrderException {
        Order order = null;
        try {
            order = orderRepository.findById(orderId).get();
        } catch (NoSuchElementException e) {
            throw new OrderException("Cannot find specified order.");
        }
        return order;
    }

    /**
     * Find all saved orders
     * 
     * @return all saved orders
     */
    public List<Order> findAll() {
        return orderRepository.findAll();
    }

    /**
     * Save a new order to repository
     * 
     * @param order the item to save
     * @return the item saved with autogenerated id
     */
    public Order save(@Valid Order order) {
        return orderRepository.save(order);
    }

    /**
     * Assign a date time to an order
     * 
     * @param orderId  the order to update
     * @param dateTime the datetime to set
     * @return the order updated
     * @throws OrderException if cannot find order or if order STATE is not
     *                        consistent
     */
    public Order schedule(Long orderId, Date dateTime) throws OrderException {
        Order order = this.findById(orderId);

        if (order.getState() != State.CANCELED || order.getState() != State.COMPLETED) {
            order.setState((order.getDateTime() == null && dateTime != null) ? order.getState().nextState()
                    : order.getState());
            order.setDateTime(dateTime);
            return orderRepository.update(order);
        } else {
            throw new OrderException("Cannot schedule a canceled order.");
        }
    }

    /**
     * Cancel an order updating its state
     * 
     * @param orderId the order to cancel
     * @return the cancelled order
     * @throws OrderException if cannot find order
     */
    public Order cancel(Long orderId) throws OrderException {

        Order order = this.findById(orderId);

        order.setState(State.CANCELED);
        order.setLastModifyDate(new Date());
        return orderRepository.update(order);
    }

    /**
     * Update an order
     * 
     * @param orderId      the order id to update
     * @param orderDetails the order to update
     * @return the updated order
     * @throws OrderException if cannot find order or if order STATE is not
     *                        consistent
     */
    public Order update(Long orderId, Order orderDetails) throws OrderException {

        Order order = this.findById(orderId);
        if (order.getState() != State.CANCELED || order.getState() != State.COMPLETED) {
            order.setEmail(orderDetails.getEmail());
            order.setName(orderDetails.getName());
            order.setCellNumber(orderDetails.getCellNumber());
            order.setLogisticInfo(orderDetails.getLogisticInfo());
            order.setLastModifyDate(new Date());
            order.setSurname(orderDetails.getSurname());
            order.setState((order.getDateTime() != null && orderDetails.getDateTime() == null)
                    ? order.getState().previousState()
                    : (order.getDateTime() == null && orderDetails.getDateTime() != null) ? order.getState().nextState()
                            : order.getState());
            order.setDateTime(orderDetails.getDateTime());
            return orderRepository.update(order);
        } else
            throw new OrderException("Cannot update a canceled order.");

    }

    /**
     * Delete an order from repository
     * 
     * @param orderId the id of the order
     * @return true if deleted, false otherwise
     * @throws OrderException if cannot find order
     */
    public boolean delete(Long orderId) throws OrderException {

        Order order = this.findById(orderId);

        return orderRepository.delete(order);
    }

    /**
     * Assign a specified order to a photographer and update its state
     * 
     * @param orderId the id of the order to assign
     * @return the modified order
     * @throws OrderException if cannot find order or if order STATE is not
     *                        consistent
     */
    public Order assign(Long orderId) throws OrderException {
        Order order = this.findById(orderId);

        if (order.getState() == State.PENDING) {
            order.setState(order.getState().nextState());
            order.setPhotographerId(this.choosePhotographer());
            return orderRepository.update(order);
        } else {
            throw new OrderException("Cannot assign an order that is not in PENDING state.");
        }
    }

    /**
     * Upload a base64 string of zip file to an order and update its state
     * 
     * @param orderId     the id of the order to update
     * @param base64Files the base64 containing the zip file
     * @return the updated Order
     * @throws OrderException if cannot find order or if order STATE is not
     *                        consistent
     */
    public Order upload(Long orderId, String base64Files) throws OrderException {
        Order order = this.findById(orderId);

        if (order.getState() == State.ASSIGNED) {
            order.setState(order.getState().nextState());
            order.setPhotoZip(base64Files);
            return orderRepository.update(order);
        } else {
            throw new OrderException("Cannot upload a file for and order that is not in ASSIGNED state.");
        }
    }

    /**
     * Accept photos uploaded by photographers and update its state
     * 
     * @param orderId the id of the order to accept
     * @return the updated order
     * @throws OrderException if cannot find order or if order STATE is not
     *                        consistent
     */
    public Order accept(Long orderId) throws OrderException {
        Order order = this.findById(orderId);

        if (order.getState() == State.UPLOADED) {
            order.setState(order.getState().nextState());
            return orderRepository.update(order);
        } else {
            throw new OrderException("Cannot accept an order that is not in UPLOADED state.");
        }
    }

    /**
     * Reject photos uploaded by photographers, delete zip content and update its
     * state
     * 
     * @param orderId the id of the order to reject
     * @return the updated order
     * @throws OrderException if cannot find order or if order STATE is not
     *                        consistent
     */
    public Order reject(Long orderId) throws OrderException {
        Order order = this.findById(orderId);

        if (order.getState() == State.UPLOADED) {
            order.setState(order.getState().previousState());
            order.setPhotoZip("");
            return orderRepository.update(order);
        } else {
            throw new OrderException("Cannot reject an order that is not in UPLOADED state.");
        }
    }

    /**
     * Choose a random photographer from a list returned by a REST service
     * 
     * @return the Id of the choosen photographer
     */
    private Long choosePhotographer() {
        RestTemplate restTemplate = new RestTemplate();
        ResponseEntity<Photographer[]> response = restTemplate.getForEntity(MOCKED_PHOTOGRAPHERS_URL,
                Photographer[].class);
        Photographer[] employees = response.getBody();
        Random random = new Random();
        int index = random.ints(0, employees.length).findFirst().getAsInt();
        return employees[index].getId();

    }

}
